pub mod simple;

#[cfg(feature = "llvm-backend")]
pub mod llvm;

use crate::ast::{Program, Statement, Expression, FunctionStatement, LetStatement, ReturnStatement};
use crate::error::CompilerError;
use crate::compiler::CompilerOptions;

pub trait CodeGenerator {
    fn generate(&mut self, program: &Program) -> Result<(), CompilerError>;
    fn write_to_file(&self, module: &str, output_path: &std::path::Path) -> Result<(), CompilerError>;
}

pub struct SimpleCodeGenerator {
    options: CompilerOptions,
}

impl SimpleCodeGenerator {
    pub fn new(options: CompilerOptions) -> Result<Self, CompilerError> {
        Ok(Self { options })
    }
}

impl CodeGenerator for SimpleCodeGenerator {
    fn generate(&mut self, program: &Program) -> Result<(), CompilerError> {
        // Delegate to simple implementation
        simple::generate_simple_code(program)
    }

    fn write_to_file(&self, _module: &str, output_path: &std::path::Path) -> Result<(), CompilerError> {
        // For simple backend, we just write the generated code to a file
        let output = format!("// Generated by Neksis Simple Backend\n// Output: {:?}\n", output_path);
        std::fs::write(output_path, output)
            .map_err(|e| CompilerError::codegen_error("simple", &format!("Failed to write output: {}", e)))?;
        Ok(())
    }
}

#[cfg(feature = "llvm-backend")]
pub struct LLVMCodeGenerator {
    options: CompilerOptions,
}

#[cfg(feature = "llvm-backend")]
impl LLVMCodeGenerator {
    pub fn new(options: CompilerOptions) -> Result<Self, CompilerError> {
        Ok(Self { options })
    }
}

#[cfg(feature = "llvm-backend")]
impl CodeGenerator for LLVMCodeGenerator {
    fn generate(&mut self, program: &Program) -> Result<(), CompilerError> {
        llvm::generate_llvm_ir(program)
    }

    fn write_to_file(&self, module: &str, output_path: &std::path::Path) -> Result<(), CompilerError> {
        // Write LLVM IR to file
        std::fs::write(output_path, module)
            .map_err(|e| CompilerError::codegen_error(&format!("Failed to write LLVM IR: {}", e)))?;
        Ok(())
    }
}

pub fn create_code_generator(options: CompilerOptions) -> Result<Box<dyn CodeGenerator>, CompilerError> {
    #[cfg(feature = "llvm-backend")]
    {
        // Try LLVM first if available
        if let Ok(llvm_gen) = LLVMCodeGenerator::new(options.clone()) {
            return Ok(Box::new(llvm_gen));
        }
    }
    
    // Fall back to simple backend
    let simple_gen = SimpleCodeGenerator::new(options)?;
    Ok(Box::new(simple_gen))
} 