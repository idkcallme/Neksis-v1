// ========================================
// COMPREHENSIVE NEXUS LANGUAGE TEST SUITE
// ========================================
// This file tests every feature of the neksis language
// from simple to complex implementations

// ========================================
// 1. BASIC LITERALS AND TYPES
// ========================================

fn test_literals() -> Int {
    let int_val: Int = 42;
    let float_val: Float = 3.14;
    let bool_val: Bool = true;
    let string_val: String = "Hello, neksis!";
    let char_val: Char = 'A';
    let null_val = null;
    
    // Array literal
    let array_val: Array<Int> = [1, 2, 3, 4, 5];
    
    // Verify all literals work
    if int_val == 42 && float_val == 3.14 && bool_val == true {
        return 1;
    }
    return 0;
}

// ========================================
// 2. BASIC EXPRESSIONS AND OPERATORS
// ========================================

fn test_arithmetic_operators() -> Int {
    let a: Int = 10;
    let b: Int = 3;
    
    let sum = a + b;        // 13
    let diff = a - b;       // 7
    let product = a * b;    // 30
    let quotient = a / b;   // 3
    let remainder = a % b;  // 1
    
    if sum == 13 && diff == 7 && product == 30 && quotient == 3 && remainder == 1 {
        return 1;
    }
    return 0;
}

fn test_comparison_operators() -> Bool {
    let x: Int = 5;
    let y: Int = 10;
    
    let less = x < y;           // true
    let less_equal = x <= y;    // true
    let greater = x > y;        // false
    let greater_equal = x >= y; // false
    let equal = x == y;         // false
    let not_equal = x != y;     // true
    
    return less && less_equal && !greater && !greater_equal && !equal && not_equal;
}

fn test_logical_operators() -> Bool {
    let a: Bool = true;
    let b: Bool = false;
    
    let and_result = a && b;    // false
    let or_result = a || b;     // true
    let not_a = !a;             // false
    let not_b = !b;             // true
    
    return !and_result && or_result && !not_a && not_b;
}

// ========================================
// 3. VARIABLES AND ASSIGNMENT
// ========================================

fn test_variables() -> Int {
    let immutable: Int = 100;
    let mut mutable: Int = 200;
    
    // Test assignment
    mutable = 300;
    
    // Test compound assignment
    mutable += 50;  // 350
    mutable -= 25;  // 325
    mutable *= 2;   // 650
    mutable /= 5;   // 130
    
    if immutable == 100 && mutable == 130 {
        return 1;
    }
    return 0;
}

// ========================================
// 4. CONTROL FLOW
// ========================================

fn test_if_statements() -> Int {
    let x: Int = 10;
    let y: Int = 20;
    
    let result: Int;
    if x < y {
        result = x + y;
    } else {
        result = x - y;
    }
    
    if result == 30 {
        return 1;
    }
    return 0;
}

fn test_while_loops() -> Int {
    let mut counter: Int = 0;
    let mut sum: Int = 0;
    
    while counter < 5 {
        sum += counter;
        counter += 1;
    }
    
    // sum should be 0 + 1 + 2 + 3 + 4 = 10
    if sum == 10 {
        return 1;
    }
    return 0;
}

fn test_loop_construct() -> Int {
    let mut count: Int = 0;
    
    loop {
        count += 1;
        if count >= 5 {
            break;
        }
    }
    
    if count == 5 {
        return 1;
    }
    return 0;
}

// ========================================
// 5. FUNCTIONS
// ========================================

fn test_function_calls() -> Int {
    let result = add_numbers(5, 3);
    if result == 8 {
        return 1;
    }
    return 0;
}

fn add_numbers(a: Int, b: Int) -> Int {
    return a + b;
}

fn test_function_without_return() {
    let x: Int = 42;
    // Function should compile without explicit return
}

fn test_recursive_function() -> Int {
    return factorial(5);
}

fn factorial(n: Int) -> Int {
    if n <= 1 {
        return 1;
    }
    return n * factorial(n - 1);
}

// ========================================
// 6. BLOCKS AND SCOPE
// ========================================

fn test_blocks() -> Int {
    let outer: Int = 10;
    
    let result = {
        let inner: Int = 20;
        outer + inner
    };
    
    if result == 30 {
        return 1;
    }
    return 0;
}

// ========================================
// 7. STRUCTS
// ========================================

struct Point {
    x: Int,
    y: Int,
}

struct Rectangle {
    top_left: Point,
    width: Int,
    height: Int,
}

fn test_structs() -> Int {
    let point = Point { x: 10, y: 20 };
    let rect = Rectangle {
        top_left: point,
        width: 100,
        height: 50,
    };
    
    if point.x == 10 && point.y == 20 && rect.width == 100 {
        return 1;
    }
    return 0;
}

fn test_struct_methods() -> Int {
    let point = Point { x: 5, y: 10 };
    let distance = point.distance_from_origin();
    
    if distance == 15 {  // 5 + 10
        return 1;
    }
    return 0;
}

impl Point {
    fn distance_from_origin(self) -> Int {
        return self.x + self.y;
    }
}

// ========================================
// 8. ENUMS
// ========================================

enum Color {
    Red,
    Green,
    Blue,
    RGB(Int, Int, Int),
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}

fn test_enums() -> Int {
    let red = Color::Red;
    let rgb = Color::RGB(255, 128, 0);
    
    let result = match red {
        Color::Red => 1,
        Color::Green => 2,
        Color::Blue => 3,
        Color::RGB(r, g, b) => r + g + b,
    };
    
    if result == 1 {
        return 1;
    }
    return 0;
}

// ========================================
// 9. PATTERN MATCHING
// ========================================

fn test_pattern_matching() -> Int {
    let value: Int = 42;
    
    let result = match value {
        0 => "zero",
        1 => "one",
        42 => "forty-two",
        _ => "other",
    };
    
    if result == "forty-two" {
        return 1;
    }
    return 0;
}

fn test_destructuring() -> Int {
    let point = Point { x: 10, y: 20 };
    
    let Point { x, y } = point;
    
    if x == 10 && y == 20 {
        return 1;
    }
    return 0;
}

// ========================================
// 10. MEMORY MANAGEMENT
// ========================================

fn test_memory_operations() -> Int {
    // Test malloc
    let ptr = malloc(100);
    
    // Test realloc
    let new_ptr = realloc(ptr, 200);
    
    // Test free
    free(new_ptr);
    
    return 1; // If we get here without crashing, it worked
}

// ========================================
// 11. OWNERSHIP AND BORROWING
// ========================================

fn test_ownership() -> Int {
    let original = String::from("hello");
    let moved = move original;  // Transfer ownership
    
    // original is no longer valid here
    return 1;
}

fn test_borrowing() -> Int {
    let mut value = 42;
    let borrowed = &value;      // Immutable borrow
    let borrowed_mut = &mut value; // Mutable borrow
    
    *borrowed_mut = 100;
    
    if value == 100 {
        return 1;
    }
    return 0;
}

fn test_clone() -> Int {
    let original = String::from("test");
    let cloned = clone original;
    
    // Both should be valid
    if original == "test" && cloned == "test" {
        return 1;
    }
    return 0;
}

// ========================================
// 12. ERROR HANDLING
// ========================================

fn test_try_catch() -> Int {
    let result = try {
        // This should succeed
        42
    } catch {
        // This should not execute
        0
    };
    
    if result == 42 {
        return 1;
    }
    return 0;
}

fn test_error_propagation() -> Int {
    let result = try {
        let value = try {
            100
        } catch {
            0
        };
        value * 2
    } catch {
        0
    };
    
    if result == 200 {
        return 1;
    }
    return 0;
}

// ========================================
// EXCEPTION HANDLING TESTS
// ========================================
fn test_throw_catch() -> Int {
    let result: Int;
    try {
        throw "error!";
        result = 0; // Should not reach here
    } catch (e) {
        result = 1; // Should catch
    }
    return result;
}

fn test_throw_uncaught() -> Int {
    try {
        throw "fail!";
        return 0; // Should not reach here
    } catch (e) {
        return 1; // Should catch
    }
    return 0;
}

fn test_finally_runs() -> Int {
    let x: Int = 0;
    try {
        throw "fail!";
    } catch (e) {
        // do nothing
    } finally {
        x = 42;
    }
    return x;
}

// ========================================
// 13. GENERICS
// ========================================

fn test_generic_function() -> Int {
    let int_result = identity(42);
    let string_result = identity("hello");
    
    if int_result == 42 && string_result == "hello" {
        return 1;
    }
    return 0;
}

fn identity<T>(value: T) -> T {
    return value;
}

struct GenericContainer<T> {
    value: T,
}

fn test_generic_struct() -> Int {
    let int_container = GenericContainer { value: 42 };
    let string_container = GenericContainer { value: "test" };
    
    if int_container.value == 42 {
        return 1;
    }
    return 0;
}

// ========================================
// 14. TRAITS
// ========================================

trait Printable {
    fn print(self);
}

impl Printable for Int {
    fn print(self) {
        // Implementation would go here
    }
}

fn test_traits() -> Int {
    let value: Int = 42;
    value.print();
    return 1;
}

// ========================================
// 15. MODULES
// ========================================

mod math {
    pub fn add(a: Int, b: Int) -> Int {
        return a + b;
    }
    
    pub fn multiply(a: Int, b: Int) -> Int {
        return a * b;
    }
}

fn test_modules() -> Int {
    let sum = math::add(5, 3);
    let product = math::multiply(4, 6);
    
    if sum == 8 && product == 24 {
        return 1;
    }
    return 0;
}

// ========================================
// MODULE/IMPORT TESTS
// ========================================
import math;
from math import add;

fn test_import_basic() -> Int {
    if math::add(2, 3) == 5 {
        return 1;
    }
    return 0;
}

fn test_from_import() -> Int {
    if add(4, 5) == 9 {
        return 1;
    }
    return 0;
}

// ========================================
// 16. CONCURRENCY
// ========================================

fn test_spawn() -> Int {
    let handle = spawn {
        42
    };
    
    let result = join handle;
    
    if result == 42 {
        return 1;
    }
    return 0;
}

fn test_channels() -> Int {
    let (sender, receiver) = channel();
    
    spawn {
        sender.send(100);
    };
    
    let value = receiver.recv();
    
    if value == 100 {
        return 1;
    }
    return 0;
}

// ========================================
// 17. ADVANCED FEATURES
// ========================================

fn test_advanced_patterns() -> Int {
    let values = [1, 2, 3, 4, 5];
    
    let sum = {
        let mut total = 0;
        let mut i = 0;
        while i < 5 {
            total += values[i];
            i += 1;
        }
        total
    };
    
    if sum == 15 {
        return 1;
    }
    return 0;
}

fn test_nested_structures() -> Int {
    struct Complex {
        simple: Int,
        nested: Point,
        optional: Option<Int>,
    }
    
    let complex = Complex {
        simple: 42,
        nested: Point { x: 10, y: 20 },
        optional: Some(100),
    };
    
    if complex.simple == 42 && complex.nested.x == 10 {
        return 1;
    }
    return 0;
}

// ========================================
// 18. EDGE CASES AND ERROR CONDITIONS
// ========================================

fn test_edge_cases() -> Int {
    // Test empty blocks
    let empty_result = {};
    
    // Test nested if statements
    let nested_result = if true {
        if false {
            0
        } else {
            1
        }
    } else {
        2
    };
    
    // Test complex expressions
    let complex = (1 + 2) * (3 + 4) / 2;
    
    if nested_result == 1 && complex == 10 {
        return 1;
    }
    return 0;
}

// ========================================
// 19. PERFORMANCE AND OPTIMIZATION TESTS
// ========================================

fn test_optimization_candidates() -> Int {
    // Constant folding test
    let constant_result = 2 + 3 * 4;  // Should be 14
    
    // Dead code elimination test
    let unused = 42;
    let used = 100;
    
    // Loop optimization test
    let mut sum = 0;
    let mut i = 0;
    while i < 10 {
        sum += i;
        i += 1;
    }
    
    if constant_result == 14 && used == 100 && sum == 45 {
        return 1;
    }
    return 0;
}

// ========================================
// LAMBDA AND FIRST-CLASS FUNCTION TESTS
// ========================================
fn test_lambda_basic() -> Int {
    let add = fn(a: Int, b: Int) => a + b;
    let result = add(2, 3);
    if result == 5 {
        return 1;
    }
    return 0;
}

fn test_lambda_block() -> Int {
    let mul = fn(a: Int, b: Int) {
        let prod = a * b;
        return prod;
    };
    let result = mul(4, 5);
    if result == 20 {
        return 1;
    }
    return 0;
}

fn test_lambda_as_argument() -> Int {
    fn apply_twice(f: fn(Int) -> Int, x: Int) -> Int {
        return f(f(x));
    }
    let inc = fn(y: Int) => y + 1;
    let result = apply_twice(inc, 10);
    if result == 12 {
        return 1;
    }
    return 0;
}

// ========================================
// CLASS, METHOD, AND INHERITANCE TESTS
// ========================================
class Animal {
    name: String,
    fn speak(self) -> String {
        return self.name + " makes a sound";
    }
}

class Dog extends Animal {
    fn speak(self) -> String {
        return self.name + " barks";
    }
}

fn test_class_basic() -> Int {
    let a = Animal { name: "Generic" };
    if a.speak() == "Generic makes a sound" {
        return 1;
    }
    return 0;
}

fn test_class_inheritance() -> Int {
    let d = Dog { name: "Fido" };
    if d.speak() == "Fido barks" {
        return 1;
    }
    return 0;
}

// ========================================
// DICTIONARY/MAP AND SET TESTS
// ========================================
fn test_dict_literal() -> Int {
    let d = {"a": 1, "b": 2, "c": 3};
    if d["a"] == 1 && d["b"] == 2 && d["c"] == 3 {
        return 1;
    }
    return 0;
}

fn test_set_literal() -> Int {
    let s = {1, 2, 3};
    if s.contains(2) && !s.contains(4) {
        return 1;
    }
    return 0;
}

// ========================================
// STRING INTERPOLATION TESTS
// ========================================
fn test_interpolation_basic() -> Int {
    let name = "World";
    let s = "Hello, {name}!";
    if s == "Hello, World!" {
        return 1;
    }
    return 0;
}

fn test_interpolation_expr() -> Int {
    let x = 5;
    let y = 7;
    let s = "Sum: {x + y}";
    if s == "Sum: 12" {
        return 1;
    }
    return 0;
}

fn test_interpolation_multiple() -> Int {
    let a = 1;
    let b = 2;
    let s = "{a} + {b} = {a + b}";
    if s == "1 + 2 = 3" {
        return 1;
    }
    return 0;
}

// ========================================
// COMPREHENSION AND SLICING TESTS
// ========================================
fn test_list_comprehension_basic() -> Int {
    let xs = [1, 2, 3, 4, 5];
    let ys = [x * 2 for x in xs];
    if ys[0] == 2 && ys[4] == 10 {
        return 1;
    }
    return 0;
}

fn test_list_comprehension_conditional() -> Int {
    let xs = [1, 2, 3, 4, 5];
    let ys = [x for x in xs if x % 2 == 0];
    if ys[0] == 2 && ys[1] == 4 {
        return 1;
    }
    return 0;
}

fn test_slicing_basic() -> Int {
    let xs = [10, 20, 30, 40, 50];
    let ys = xs[1:4];
    if ys[0] == 20 && ys[2] == 40 {
        return 1;
    }
    return 0;
}

fn test_slicing_with_step() -> Int {
    let xs = [1, 2, 3, 4, 5, 6];
    let ys = xs[0:6:2];
    if ys[0] == 1 && ys[1] == 3 && ys[2] == 5 {
        return 1;
    }
    return 0;
}

// ========================================
// DEFAULT AND KEYWORD ARGUMENT TESTS
// ========================================
fn test_default_args() -> Int {
    fn add(a: Int, b: Int = 10) -> Int {
        return a + b;
    }
    let x = add(5);
    let y = add(5, 7);
    if x == 15 && y == 12 {
        return 1;
    }
    return 0;
}

fn test_keyword_args() -> Int {
    fn mul(a: Int, b: Int) -> Int {
        return a * b;
    }
    let x = mul(a=3, b=4);
    let y = mul(b=5, a=2);
    if x == 12 && y == 10 {
        return 1;
    }
    return 0;
}

fn test_default_and_keyword_args() -> Int {
    fn sub(a: Int, b: Int = 2, c: Int = 1) -> Int {
        return a - b - c;
    }
    let x = sub(10);
    let y = sub(10, c=3);
    let z = sub(10, b=4, c=2);
    if x == 7 && y == 5 && z == 4 {
        return 1;
    }
    return 0;
}

// ========================================
// 20. MAIN TEST RUNNER
// ========================================

fn main() -> Int {
    let mut passed = 0;
    let mut total = 0;
    
    // Run all tests
    total += 1;
    if test_literals() == 1 { passed += 1; }
    
    total += 1;
    if test_arithmetic_operators() == 1 { passed += 1; }
    
    total += 1;
    if test_comparison_operators() == true { passed += 1; }
    
    total += 1;
    if test_logical_operators() == true { passed += 1; }
    
    total += 1;
    if test_variables() == 1 { passed += 1; }
    
    total += 1;
    if test_if_statements() == 1 { passed += 1; }
    
    total += 1;
    if test_while_loops() == 1 { passed += 1; }
    
    total += 1;
    if test_loop_construct() == 1 { passed += 1; }
    
    total += 1;
    if test_function_calls() == 1 { passed += 1; }
    
    total += 1;
    if test_recursive_function() == 120 { passed += 1; }  // 5! = 120
    
    total += 1;
    if test_blocks() == 1 { passed += 1; }
    
    total += 1;
    if test_structs() == 1 { passed += 1; }
    
    total += 1;
    if test_struct_methods() == 1 { passed += 1; }
    
    total += 1;
    if test_enums() == 1 { passed += 1; }
    
    total += 1;
    if test_pattern_matching() == 1 { passed += 1; }
    
    total += 1;
    if test_destructuring() == 1 { passed += 1; }
    
    total += 1;
    if test_memory_operations() == 1 { passed += 1; }
    
    total += 1;
    if test_ownership() == 1 { passed += 1; }
    
    total += 1;
    if test_borrowing() == 1 { passed += 1; }
    
    total += 1;
    if test_clone() == 1 { passed += 1; }
    
    total += 1;
    if test_try_catch() == 1 { passed += 1; }
    
    total += 1;
    if test_error_propagation() == 1 { passed += 1; }
    
    total += 1;
    if test_throw_catch() == 1 { passed += 1; }
    
    total += 1;
    if test_throw_uncaught() == 1 { passed += 1; }
    
    total += 1;
    if test_finally_runs() == 42 { passed += 1; }
    
    total += 1;
    if test_generic_function() == 1 { passed += 1; }
    
    total += 1;
    if test_generic_struct() == 1 { passed += 1; }
    
    total += 1;
    if test_traits() == 1 { passed += 1; }
    
    total += 1;
    if test_modules() == 1 { passed += 1; }
    
    total += 1;
    if test_spawn() == 1 { passed += 1; }
    
    total += 1;
    if test_channels() == 1 { passed += 1; }
    
    total += 1;
    if test_advanced_patterns() == 1 { passed += 1; }
    
    total += 1;
    if test_nested_structures() == 1 { passed += 1; }
    
    total += 1;
    if test_edge_cases() == 1 { passed += 1; }
    
    total += 1;
    if test_optimization_candidates() == 1 { passed += 1; }
    
    total += 1;
    if test_lambda_basic() == 1 { passed += 1; }
    total += 1;
    if test_lambda_block() == 1 { passed += 1; }
    total += 1;
    if test_lambda_as_argument() == 1 { passed += 1; }
    
    total += 1;
    if test_default_args() == 1 { passed += 1; }
    total += 1;
    if test_keyword_args() == 1 { passed += 1; }
    total += 1;
    if test_default_and_keyword_args() == 1 { passed += 1; }
    
    total += 1;
    if test_class_basic() == 1 { passed += 1; }
    total += 1;
    if test_class_inheritance() == 1 { passed += 1; }
    
    total += 1;
    if test_dict_literal() == 1 { passed += 1; }
    total += 1;
    if test_set_literal() == 1 { passed += 1; }
    
    total += 1;
    if test_interpolation_basic() == 1 { passed += 1; }
    total += 1;
    if test_interpolation_expr() == 1 { passed += 1; }
    total += 1;
    if test_interpolation_multiple() == 1 { passed += 1; }
    
    total += 1;
    if test_list_comprehension_basic() == 1 { passed += 1; }
    total += 1;
    if test_list_comprehension_conditional() == 1 { passed += 1; }
    total += 1;
    if test_slicing_basic() == 1 { passed += 1; }
    total += 1;
    if test_slicing_with_step() == 1 { passed += 1; }
    
    total += 1;
    if test_import_basic() == 1 { passed += 1; }
    total += 1;
    if test_from_import() == 1 { passed += 1; }
    
    // Return the number of passed tests
    return passed;
} 