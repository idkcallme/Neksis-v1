// Neksis Tutorial: Advanced Algorithms
// Run with: neksis examples/04_algorithms.nx

// Bubble sort algorithm
fn bubbleSort(arr: [Int; 10]) -> [Int; 10] {
    let n: Int = 10;
    let i: Int = 0;
    while i < n - 1 {
        let j: Int = 0;
        while j < n - i - 1 {
            if arr[j] > arr[j + 1] {
                // Swap elements
                let temp: Int = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return arr;
}

// Binary search algorithm
fn binarySearch(arr: [Int; 10], target: Int) -> Int {
    let left: Int = 0;
    let right: Int = 9;
    
    while left <= right {
        let mid: Int = left + (right - left) / 2;
        
        if arr[mid] == target {
            return mid;
        }
        
        if arr[mid] < target {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1; // Not found
}

// Greatest Common Divisor (Euclidean algorithm)
fn gcd(a: Int, b: Int) -> Int {
    while b != 0 {
        let temp: Int = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// Least Common Multiple
fn lcm(a: Int, b: Int) -> Int {
    return (a * b) / gcd(a, b);
}

// Collatz sequence length
fn collatzLength(n: Int) -> Int {
    let count: Int = 0;
    while n != 1 {
        if n % 2 == 0 {
            n = n / 2;
        } else {
            n = 3 * n + 1;
        }
        count = count + 1;
    }
    return count;
}

// Digital root calculation
fn digitalRoot(n: Int) -> Int {
    while n >= 10 {
        let sum: Int = 0;
        while n > 0 {
            sum = sum + (n % 10);
            n = n / 10;
        }
        n = sum;
    }
    return n;
}

// Perfect number check
fn isPerfect(n: Int) -> Bool {
    if n <= 1 {
        return false;
    }
    
    let sum: Int = 1;
    let i: Int = 2;
    while i * i <= n {
        if n % i == 0 {
            sum = sum + i;
            if i != n / i {
                sum = sum + (n / i);
            }
        }
        i = i + 1;
    }
    
    return sum == n;
}

fn main() -> Int {
    println("=== ADVANCED ALGORITHMS TUTORIAL ===");
    
    // 1. Sorting Algorithm
    println("\n=== BUBBLE SORT ===");
    let unsorted: [Int; 10] = [64, 34, 25, 12, 22, 11, 90, 88, 76, 50];
    println("Unsorted array: " + unsorted[0] + ", " + unsorted[1] + ", " + unsorted[2] + "...");
    
    let sorted: [Int; 10] = bubbleSort(unsorted);
    println("Sorted array: " + sorted[0] + ", " + sorted[1] + ", " + sorted[2] + "...");
    
    // 2. Binary Search
    println("\n=== BINARY SEARCH ===");
    let target: Int = 25;
    let position: Int = binarySearch(sorted, target);
    if position != -1 {
        println("Found " + target + " at index " + position);
    } else {
        println(target + " not found");
    }
    
    // 3. GCD and LCM
    println("\n=== GCD AND LCM ===");
    let a: Int = 48;
    let b: Int = 18;
    println("GCD(" + a + ", " + b + ") = " + gcd(a, b));
    println("LCM(" + a + ", " + b + ") = " + lcm(a, b));
    
    // 4. Collatz Conjecture
    println("\n=== COLLATZ SEQUENCE ===");
    let num: Int = 1;
    while num <= 10 {
        let length: Int = collatzLength(num);
        println("Collatz length for " + num + " = " + length);
        num = num + 1;
    }
    
    // 5. Digital Root
    println("\n=== DIGITAL ROOT ===");
    println("Digital root of 123456 = " + digitalRoot(123456));
    println("Digital root of 999 = " + digitalRoot(999));
    println("Digital root of 87654321 = " + digitalRoot(87654321));
    
    // 6. Perfect Numbers
    println("\n=== PERFECT NUMBERS ===");
    let testNum: Int = 1;
    while testNum <= 30 {
        if isPerfect(testNum) {
            println(testNum + " is a perfect number");
        }
        testNum = testNum + 1;
    }
    
    return 0;
}
