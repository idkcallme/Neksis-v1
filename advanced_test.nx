// Advanced Optimization Test for neksis Compiler
// This file tests sophisticated optimization scenarios

// Advanced data structure with optimization opportunities
struct Matrix {
    data: Array<Array<Float>>,
    rows: Int,
    cols: Int,
}

// Matrix operations with optimization opportunities
fn matrix_multiply(a: Matrix, b: Matrix) -> Matrix {
    let result = Matrix {
        data: Array::new(),
        rows: a.rows,
        cols: b.cols,
    };
    
    // Loop optimization opportunities
    let i = 0;
    while i < a.rows {
        let j = 0;
        while j < b.cols {
            let k = 0;
            let sum = 0.0;
            while k < a.cols {
                sum = sum + a.data[i][k] * b.data[k][j];
                k = k + 1;
            }
            result.data[i][j] = sum;
            j = j + 1;
        }
        i = i + 1;
    }
    
    result
}

// Recursive algorithms with tail call optimization opportunities
fn fibonacci_tail(n: Int, a: Int, b: Int) -> Int {
    if n <= 1 {
        b
    } else {
        fibonacci_tail(n - 1, b, a + b)  // Tail call
    }
}

fn fibonacci(n: Int) -> Int {
    fibonacci_tail(n, 0, 1)
}

// Complex sorting algorithm with optimization opportunities
fn quicksort(arr: Array<Int>, low: Int, high: Int) -> Array<Int> {
    if low < high {
        let pivot = partition(arr, low, high);
        quicksort(arr, low, pivot - 1);
        quicksort(arr, pivot + 1, high);
    }
    arr
}

fn partition(arr: Array<Int>, low: Int, high: Int) -> Int {
    let pivot = arr[high];
    let i = low - 1;
    let j = low;
    
    while j < high {
        if arr[j] <= pivot {
            i = i + 1;
            let temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        j = j + 1;
    }
    
    let temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    
    i + 1
}

// Memory-intensive operations with optimization opportunities
fn create_large_array(size: Int) -> Array<Int> {
    let arr = Array::new();
    let i = 0;
    while i < size {
        arr.push(i * i);  // Strength reduction opportunity
        i = i + 1;
    }
    arr
}

// Complex mathematical computations
fn compute_pi(iterations: Int) -> Float {
    let pi = 0.0;
    let i = 0;
    while i < iterations {
        let term = 4.0 / (2.0 * i + 1.0);
        if i % 2 == 0 {
            pi = pi + term;
        } else {
            pi = pi - term;
        }
        i = i + 1;
    }
    pi
}

// String processing with optimization opportunities
fn reverse_string(s: String) -> String {
    let result = "";
    let i = s.length() - 1;
    while i >= 0 {
        result = result + s[i];
        i = i - 1;
    }
    result
}

// Advanced function inlining candidates
fn square(x: Int) -> Int {
    x * x
}

fn cube(x: Int) -> Int {
    x * x * x
}

fn power4(x: Int) -> Int {
    square(square(x))  // Function composition
}

// Complex conditional logic with dead code elimination opportunities
fn complex_condition(x: Int, y: Int) -> Int {
    let result = 0;
    
    if x > 100 && y < 50 {
        result = 1;
    } else if x <= 100 && y >= 50 {
        result = 2;
    } else if false {  // Dead code
        result = 999;
    }
    
    if x == 0 || y == 0 {
        result = result + 10;
    }
    
    result
}

// Vector operations with SIMD optimization opportunities
fn vector_add(a: Array<Float>, b: Array<Float>) -> Array<Float> {
    let result = Array::new();
    let i = 0;
    while i < a.length() {
        result.push(a[i] + b[i]);
        i = i + 1;
    }
    result
}

fn vector_multiply(a: Array<Float>, b: Array<Float>) -> Array<Float> {
    let result = Array::new();
    let i = 0;
    while i < a.length() {
        result.push(a[i] * b[i]);
        i = i + 1;
    }
    result
}

// Cache-friendly matrix operations
fn matrix_transpose(m: Matrix) -> Matrix {
    let result = Matrix {
        data: Array::new(),
        rows: m.cols,
        cols: m.rows,
    };
    
    let i = 0;
    while i < m.rows {
        let j = 0;
        while j < m.cols {
            result.data[j][i] = m.data[i][j];
            j = j + 1;
        }
        i = i + 1;
    }
    
    result
}

// Advanced constant folding opportunities
fn complex_math() -> Float {
    let x = 2.0 * 3.14159;  // Should be folded
    let y = 1.0 / 2.0;      // Should be folded
    let z = (x + y) * (x - y);  // Complex expression
    z
}

// Loop unrolling opportunities
fn sum_array(arr: Array<Int>) -> Int {
    let sum = 0;
    let i = 0;
    while i < arr.length() {
        sum = sum + arr[i];
        i = i + 1;
    }
    sum
}

// Common subexpression elimination opportunities
fn expensive_computation(x: Int, y: Int) -> Int {
    let temp1 = x * x + y * y;  // Expensive computation
    let temp2 = x * x + y * y;  // Same computation again
    let result = temp1 + temp2;
    result
}

// Main function to test all advanced optimizations
fn main() -> Int {
    // Test matrix operations
    let matrix_a = Matrix {
        data: Array::new(),
        rows: 2,
        cols: 2,
    };
    let matrix_b = Matrix {
        data: Array::new(),
        rows: 2,
        cols: 2,
    };
    let matrix_result = matrix_multiply(matrix_a, matrix_b);
    
    // Test recursive algorithms
    let fib_result = fibonacci(10);
    
    // Test sorting
    let arr = create_large_array(100);
    let sorted_arr = quicksort(arr, 0, 99);
    
    // Test mathematical computations
    let pi_approx = compute_pi(1000);
    
    // Test string operations
    let reversed = reverse_string("hello world");
    
    // Test function composition
    let power_result = power4(3);
    
    // Test complex conditions
    let condition_result = complex_condition(50, 25);
    
    // Test vector operations
    let vec_a = Array::new();
    let vec_b = Array::new();
    let vec_result = vector_add(vec_a, vec_b);
    
    // Test matrix transpose
    let transposed = matrix_transpose(matrix_a);
    
    // Test complex math
    let math_result = complex_math();
    
    // Test array operations
    let sum_result = sum_array(sorted_arr);
    
    // Test expensive computations
    let expensive_result = expensive_computation(5, 3);
    
    // Return a combination of all results
    fib_result + power_result + condition_result + sum_result + expensive_result
} 

